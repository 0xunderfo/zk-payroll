// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IERC20} from "./interfaces/IERC20.sol";

/**
 * @title ZKPayroll
 * @notice Privacy-preserving payroll using zero-knowledge proofs
 * @dev Allows batch payments where individual amounts are hidden but total is verifiable
 * 
 * Built at ETH Oxford 2026 for the Plasma Payments Bounty
 * 
 * How it works:
 * 1. Employer prepares payroll (addresses + amounts)
 * 2. Generates ZK proof that sum(amounts) = totalAmount
 * 3. Submits proof + encrypted recipient data to this contract
 * 4. Contract verifies proof and executes transfers
 * 
 * Privacy guarantees:
 * - Individual amounts are NEVER on-chain
 * - Only totalAmount is public
 * - Recipients can be stealth addresses for additional privacy
 */
contract ZKPayroll {
    // ============ Errors ============
    
    error InvalidProof();
    error InvalidRecipients();
    error InvalidTotalAmount();
    error TransferFailed();
    error Unauthorized();
    
    // ============ Events ============
    
    /// @notice Emitted when a payroll batch is executed
    /// @param employer The address that initiated the payroll
    /// @param token The token used for payment (USDT on Plasma)
    /// @param totalAmount The total amount distributed
    /// @param recipientCount Number of recipients paid
    /// @param payrollId Unique identifier for this payroll batch
    event PayrollExecuted(
        address indexed employer,
        address indexed token,
        uint256 totalAmount,
        uint256 recipientCount,
        bytes32 indexed payrollId
    );
    
    /// @notice Emitted when a payment is made (minimal info for privacy)
    /// @param payrollId The payroll batch this payment belongs to
    /// @param index The index in the batch (not the amount!)
    event PaymentMade(bytes32 indexed payrollId, uint256 index);
    
    // ============ State ============
    
    /// @notice The ZK verifier contract (auto-generated by snarkjs)
    address public immutable verifier;
    
    /// @notice The payment token (USDT on Plasma)
    IERC20 public immutable paymentToken;
    
    /// @notice Nonce for generating unique payroll IDs
    uint256 public payrollNonce;
    
    /// @notice Mapping of executed payrolls (prevents replay)
    mapping(bytes32 => bool) public executedPayrolls;
    
    // ============ Constructor ============
    
    /**
     * @param _verifier Address of the ZK verifier contract
     * @param _paymentToken Address of the payment token (USDT)
     */
    constructor(address _verifier, address _paymentToken) {
        verifier = _verifier;
        paymentToken = IERC20(_paymentToken);
    }
    
    // ============ Core Functions ============
    
    /**
     * @notice Execute a private payroll batch
     * @dev Verifies ZK proof and distributes funds to recipients
     * 
     * @param proof The ZK proof components (a, b, c for Groth16)
     * @param totalAmount The total amount being distributed (public input)
     * @param recipientCount Number of recipients (public input)
     * @param recipients Array of recipient addresses
     * @param encryptedAmounts Encrypted individual amounts (for recipient decryption)
     * 
     * NOTE: In production, amounts would be encrypted. For MVP, they're passed
     * but the contract trusts the proof that they sum correctly.
     * 
     * TODO: Implement proper encrypted amount scheme
     * TODO: Add stealth address support (Plasma native)
     */
    function executePayroll(
        uint256[8] calldata proof, // Groth16 proof: [a[0], a[1], b[0][0], b[0][1], b[1][0], b[1][1], c[0], c[1]]
        uint256 totalAmount,
        uint256 recipientCount,
        address[] calldata recipients,
        uint256[] calldata encryptedAmounts // For MVP: actual amounts (would be encrypted in production)
    ) external {
        // Validate inputs
        if (recipients.length != recipientCount) revert InvalidRecipients();
        if (encryptedAmounts.length != recipientCount) revert InvalidRecipients();
        if (totalAmount == 0) revert InvalidTotalAmount();
        
        // Generate payroll ID (prevents replay)
        bytes32 payrollId = keccak256(
            abi.encodePacked(
                msg.sender,
                payrollNonce++,
                totalAmount,
                recipientCount
            )
        );
        
        if (executedPayrolls[payrollId]) revert Unauthorized();
        executedPayrolls[payrollId] = true;
        
        // Verify ZK proof
        // The proof verifies that: sum(private amounts) == totalAmount
        bool valid = _verifyProof(proof, totalAmount, recipientCount);
        if (!valid) revert InvalidProof();
        
        // Transfer tokens from employer to this contract
        bool success = paymentToken.transferFrom(msg.sender, address(this), totalAmount);
        if (!success) revert TransferFailed();
        
        // Distribute to recipients
        // NOTE: For MVP, using encryptedAmounts as actual amounts
        // In production: would use commitment scheme
        for (uint256 i = 0; i < recipientCount; i++) {
            success = paymentToken.transfer(recipients[i], encryptedAmounts[i]);
            if (!success) revert TransferFailed();
            
            emit PaymentMade(payrollId, i);
        }
        
        emit PayrollExecuted(
            msg.sender,
            address(paymentToken),
            totalAmount,
            recipientCount,
            payrollId
        );
    }
    
    // ============ View Functions ============
    
    /**
     * @notice Check if a payroll has been executed
     * @param payrollId The payroll ID to check
     */
    function isPayrollExecuted(bytes32 payrollId) external view returns (bool) {
        return executedPayrolls[payrollId];
    }
    
    // ============ Internal Functions ============
    
    /**
     * @notice Verify a ZK proof
     * @dev Calls the verifier contract generated by snarkjs
     * 
     * @param proof The proof components
     * @param totalAmount Public input: total amount
     * @param recipientCount Public input: number of recipients
     */
    function _verifyProof(
        uint256[8] calldata proof,
        uint256 totalAmount,
        uint256 recipientCount
    ) internal view returns (bool) {
        // Format proof for verifier
        // Groth16 proof format: a, b, c
        uint256[2] memory a = [proof[0], proof[1]];
        uint256[2][2] memory b = [[proof[2], proof[3]], [proof[4], proof[5]]];
        uint256[2] memory c = [proof[6], proof[7]];
        
        // Public inputs array
        // Must match the order in the circuit's main component
        uint256[2] memory pubInputs = [totalAmount, recipientCount];
        
        // Call verifier
        return IVerifier(verifier).verifyProof(a, b, c, pubInputs);
    }
}

/**
 * @title IVerifier
 * @notice Interface for the auto-generated Groth16 verifier
 */
interface IVerifier {
    function verifyProof(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256[2] calldata _pubSignals
    ) external view returns (bool);
}
